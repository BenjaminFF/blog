### 一些问题思考
1.什么是**原型对象**，什么是**实例对象**？<br>
2.Function.\_\_proto\_\_===Function.prototype?

### 上帝之语(权威定义)

**对象(object)**<br>
[摘录来自ECMAScript 5.1规范的4.3.3小节：](http://yanhaijing.com/es5/#14)<br>
对象类型的成员。<br>
<font color="#006600">注：对象是属性的集合，并有一个**原型对象**。原型可以是空值。</font>

**构造器 (constructor)**<br>
[摘录来自ECMAScript 5.1规范的4.3.4小节：](http://yanhaijing.com/es5/#14)
创建和初始化对象的函数对象。<br>
<font color="#006600">注： 构造器的“prototype”属性值是一个**原型对象**，它用来实现**继承**和**共享属性**。</font>

**原型(prototype)**<br>
[摘录来自ECMAScript 5.1规范的4.3.5小节：](http://yanhaijing.com/es5/#14)
为其他对象提供**共享属性**的对象。<br>
<font color="#006600">注：当构造器创建一个对象，为了解决对象的属性引用，该对象会隐式引用构造器的“prototype”属性。通过程序表达式 constructor.prototype 可以引用到构造器的“prototype”属性，并且添加到对象原型里的属性，会通过继承与所有共享此原型的对象共享。另外，可使用 Object.create 内置函数，通过明确指定原型来创建一个新对象。</font>

### new一个person来探索原型
首先创建一个Person函数来作为一个构造函数。构造后的person有不同的属性，例如姓名，年龄等：
``` javascript
function Person(name,age) {
    this.name=name;
    this.age=age;
}
let person1 = new Person("benjamin","22");
let person2 = new Person("tony","25");
```
Person作为person1和person2的构造器，这里的person1和person2就是Person构造函数的构造出来的**实例对象**。

多个person是有**默认**的共同行为（默认属性），例如他们都能行走，说话，如果不将这些行为抽象出来，将会非常麻烦。这时候**原型**(prototype)登场：
``` javascript
Person.prototype.walk=function (){
    console.log('I can walk');
}

Person.prototype.speak=function (){
    console.log('I can speak');
}

person1.walk();     //I can walk
person2.walk();     //I can walk
```
这里的Person.prototype就是一个**原型对象**，为其它对象提供**共享属性**。

person1很不幸，出了车祸，失去了双腿，不能走路了：
``` javascript
person1.walk=function(){
    console.log("I can't walk");
}
person1.walk();   //I can't walk
```
这种行为叫做"属性遮蔽"，当使用这个实例时，实例上的属性会覆盖掉原型上的属性。

person1在车祸后，开始怀疑人生。要怎么证明我的原型是Person.prototype，而不是Dog.prototype。然后person1谷歌了一下找到了es5和一些浏览器对此的实现：
``` javascript
console.log(person1.__proto__===Person.prototype);  //true
console.log(Object.getPrototypeOf(person1)===Person.prototype);  //true
console.log(person1.__proto__===Dog.prototype);  //false
```
person1有一天去拜访他的朋友person2，听person2说他还有一个属性toString。person1试了一下，还真有，但令他疑惑的是他的原型并没有这个属性（通过hasOwnProperty()）。他不禁思考，他的原型一定还有原型。于是他又谷歌到了原型链：
``` javascript
console.log(person1.__proto__===Person.prototype);  //true
console.log(Person.prototype.__proto__===Object.prototype);  //true
console.log(Object.prototype.__proto__===null);       //true
```

然后他又想到了他的构造器Person。Person和Person.prototype的关系又是什么呢？
``` javascript
console.log(Person.prototype.constructor===Person);   //true
```

还有函数也是对象，那他也有原型吧。然而函数这个东东，一句话是说不清楚的。


### 探究函数

**函数 (function)**<br>
[摘录来自ECMAScript 5.1规范的4.3.24小节：](http://yanhaijing.com/es5/#14)<br>
对象类型的成员，标准内置构造器 Function 的一个实例，并且可做为子程序被调用。<br>
<font color="#006600">注：函数除了拥有命名的属性，还包含可执行代码、状态，用来确定被调用时的行为。函数的代码不限于 ECMAScript。</font>

函数的创建方式有三种：
``` javascript
//声明式
function fn(){ };
console.log(fn.__proto__===Function.prototype);     //true

//函数的字面量或叫直接量或称表达式
let fn=function () { };
console.log(fn.__proto__===Function.prototype);     //true

//以new Function 的形式
var fn = new Function (arg1 , arg2 ,arg3 ,…, argN , body); 
console.log(fn.__proto__===Function.prototype);    //true
console.log(Function.prototype.__proto__===Object.prototype);  //true
```
三种方式创建的函数都是Function.prototype的实例，而Function.prototype又是Object.prototype的实例。所以在new一个对象时，我们有了两条原型链：
```
person1-->Person.prototype-->Object.prototype-->null
Person-->Function.prototype->Object.prototype-->null
```
这么说person1和他的构造函数Person毫无联系了。但是为什么：
```
console.log(person1.constructor===Person);  //true
```
可以这么理解，在寻找person1的constructor属性时如果不存在会从它的原型Person.prototype去找。
```
console.log(person1.constructor===Person.prototype.constructor);  //true
console.log(Person.prototype.constructor===Person);  //true
```


#### 函数new了一下就变成了构造函数，那么"new"到底做了什么？
其实可以重写Person函数，并且不用new而直接调用Person函数来创造一个person。
``` js
function Person(name,age) {
    let temp={};
    temp.__proto__=Person.prototype;

    temp.name=name;
    temp.age=age;

    return temp;
}

Person.prototype.walk=function (){
    console.log('I can walk');
}

Person.prototype.speak=function (){
    console.log('I can speak');
}

let person1 = Person("benjamin","22");

console.log(person1.name);      //benjamin
person1.walk();          //I can walk  
```
new的作用，可以理解为少写了几行代码。

理解完了原型和函数之后，回到了第二个问题：Function.\_\_proto\_\_===Function.prototype？


### 应用
1. 检查对象是否存在某个属性用hasOwnProperty。
2. 不要直接使用Object.prototype的方法，例如hasOwnProperty, propertyIsEnumerable和isPrototypeOf。
``` js
// best
const has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope.
console.log(has.call(object, key));
```
3.Object.create(null);






























